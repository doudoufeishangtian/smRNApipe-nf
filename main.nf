#!/usr/bin/env nextflow
/*
================================================================================
--------------------------------------------------------------------------------
      NEXTFLOW pipeline for smallRNAseq analysis
         provided by @zhangdongqin2@126.com 
--------------------------------------------------------------------------------
================================================================================
smallRNAseq pipeline is a quick and easy pipeline deploy on linux/Mac system.
This pipeline is supported run on specified conda environment.
You can use environment.yml to create a conda environment for this pipeline.
You can run this pipeline on local conda env by < -with-conda /path/to/conda/env >
This pipeline is desiged and implement by Zhang.DQ < zhangdongqin2@126.com >
Pipeline visualization is supported by nf-core
================================================================================
*/

ANSI_RESET = "\u001B[0m";
ANSI_BLACK = "\u001B[30m";
ANSI_RED = "\u001B[31m";
ANSI_GREEN = "\u001B[32m";
ANSI_YELLOW = "\u001B[33m";
ANSI_BLUE = "\u001B[34m";
ANSI_PURPLE = "\u001B[35m";
ANSI_CYAN = "\u001B[36m";
ANSI_WHITE = "\u001B[37m";
def print_red = {  str -> ANSI_RED + str + ANSI_RESET }
def print_black = {  str -> ANSI_BLACK + str + ANSI_RESET }
def print_green = {  str -> ANSI_GREEN + str + ANSI_RESET }
def print_yellow = {  str -> ANSI_YELLOW + str + ANSI_RESET }
def print_blue = {  str -> ANSI_BLUE + str + ANSI_RESET }
def print_cyan = {  str -> ANSI_CYAN + str + ANSI_RESET }
def print_purple = {  str -> ANSI_PURPLE + str + ANSI_RESET }
def print_white = {  str -> ANSI_WHITE + str + ANSI_RESET }

nextflow.enable.dsl = 2

def helpMessage() {
    log.info nfcoreHeader()
    log.info"""
    A Nextflow-based miRNAseq Analysis Pipeline,version:$params.version
    Usage:

    The typical command for running the pipeline is as follows:

    nextflow run main.nf --reads 'reads/*.fq.gz'

    Required arguments:
      --reads          [file]           Path to input data (must be surrounded with quotes) < 'reads/*.fq.gz' >

    Optional arguments:
      --protocol        [str]           Sequencing protocol, default is 'illumina'
      --species         [str]           Species name of reads, default is 'hsa'
      --hairpin        [file]           Path to hairpin microRNA fasta
      --mature         [file]           Path to mature microRNA fasta          
      --gtf            [path]           Path to hsa.gff3 or other species 
      --genome         [path]           Path to reference genome fasta file 
      --help            [str]           Help information for RNAseq pipeline
      --cpus            [int]           Cpu cores for pipeline , default is 6, you can specify core numbers with < --cpu 8 >
      --bowtie_index   [path]           Path to bowtie_index,if you want to mapping smallRNA sequencing data to ref genome ,you can specify this argument
      --outdir         [path]           Path to analysis results directory ,defalut is < ./results >.
      --salmon         [bool]           Specify use salmon quant to quantify miRNA counts
      --genome_mapping [bool]           Defalut is true,you can specify false to skip genome mapping
    Other Options:
      --debug        [bool]           Flag to run only specific fusion tool/s and not the whole pipeline. Only works on tool flags.
      --outdir       [file]           The output directory where the results will be saved
      --email       [email]           Set this parameter to your e-mail address to get a summary e-mail with details of the run sent to you when the workflow exits
      --email_on_fail[email]          Same as --email, except only send mail if the workflow is not successful
      --max_multiqc_email_size [str]  Theshold size for MultiQC report to be attached in notification email. If file generated by pipeline exceeds the threshold, it will not be attached (Default: 25MB)
      -name [str]                     Name for the pipeline run. If not specified, Nextflow will automatically generate a random mnemonic

    AWSBatch options:
      --awsqueue [str]                The AWSBatch JobQueue that needs to be set when running on AWSBatch
      --awsregion [str]               The AWS Region for your AWS Batch job to run on
      --awscli [str]                  Path to the AWS CLI tool
    """.stripIndent()
}

def nfcoreHeader() {
    // Log colors ANSI codes
    c_black = params.monochrome_logs ? '' : "\033[0;30m";
    c_blue = params.monochrome_logs ? '' : "\033[0;34m";
    c_cyan = params.monochrome_logs ? '' : "\033[0;36m";
    c_dim = params.monochrome_logs ? '' : "\033[2m";
    c_green = params.monochrome_logs ? '' : "\033[0;32m";
    c_purple = params.monochrome_logs ? '' : "\033[0;35m";
    c_reset = params.monochrome_logs ? '' : "\033[0m";
    c_white = params.monochrome_logs ? '' : "\033[0;37m";
    c_yellow = params.monochrome_logs ? '' : "\033[0;33m";

    return """    -${c_dim}--------------------------------------------------${c_reset}-
                                            ${c_green},--.${c_black}/${c_green},-.${c_reset}
    ${c_blue}        ___     __   __   __   ___     ${c_green}/,-._.--~\'${c_reset}
    ${c_blue}  |\\ | |__  __ /  ` /  \\ |__) |__         ${c_yellow}}  {${c_reset}
    ${c_blue}  | \\| |       \\__, \\__/ |  \\ |___     ${c_green}\\`-._,-`-,${c_reset}
                                            ${c_green}`._,._,\'${c_reset}
    ${c_purple}  smallRNAseq analysis/@zhangdongqin2@126.com v${workflow.manifest.version}${c_reset}
    -${c_dim}--------------------------------------------------${c_reset}-
    """.stripIndent()
}

if (params.help){
    helpMessage()
    exit 0
}
clip_R1 = params.clip_R1
three_prime_clip_R1 = params.three_prime_clip_R1
three_prime_adapter = params.three_prime_adapter
protocol = params.protocol
// Presets
if (params.protocol == "illumina"){
    clip_R1 = 0
    three_prime_clip_R1 = 0
    three_prime_adapter = "TGGAATTCTCGGGTGCCAAGG"
} else if (params.protocol == "nextflex"){
    clip_R1 = 4
    three_prime_clip_R1 = 4
    three_prime_adapter = "TGGAATTCTCGGGTGCCAAGG"
} else if (params.protocol == "qiaseq"){
    clip_R1 = 0
    three_prime_clip_R1 = 0
    three_prime_adapter = "AACTGTAGGCACCATCAAT"
} else if (params.protocol == "cats"){
    clip_R1 = 3
    three_prime_clip_R1 = 0
    // three_prime_adapter = "GATCGGAAGAGCACACGTCTG"
    three_prime_adapter = "AAAAAAAA"
} else {
    //custom protocol 
    clip_R1 = params.clip_R1
    three_prime_clip_R1 = params.three_prime_clip_R1
    three_prime_adapter = params.three_prime_adapter
    protocol = params.protocol
}
if (!params.gtf && params.species){
    gtf = file("ftp://mirbase.org/pub/mirbase/CURRENT/genomes/${params.species}.gff3", checkIfExists: true)
}else if (params.gtf) {
    gtf = file(params.gtf, checkIfExists: true)
}else{
    gtf = false
}

if (params.reads){ raw_reads = Channel.fromFilePairs(params.reads,size: 1 )
                     .ifEmpty{ exit 1, "ERROR:Cannot find any reads matching: ${params.reads}\nNB: Path needs to be enclosed in quotes!" }         
}

// Header log info
log.info nfcoreHeader()

process GET_NEXTFLOW_SOFTWARE_VERSION_FOR_MIRNA_ANALYSIS {
   publishDir "${params.outdir}/pipeline_info", mode: params.publish_dir_mode

   output:
   path ("*.txt"), emit: software_version
   script:
   """
   echo $workflow.manifest.version > v_pipeline.txt
   echo $workflow.nextflow.version > v_nextflow.txt
   """
}
process GET_FASTQC_SOFTWARE_VERSION_FOR_MIRNA_ANALYSIS {
   label 'fastqc'
   publishDir "${params.outdir}/pipeline_info", mode: params.publish_dir_mode

   output:
   path ("*.txt"), emit: software_version
   script:
   """
   fastqc --version > v_fastqc.txt
   """
}
process GET_BOWTIE_SOFTWARE_VERSION_FOR_MIRNA_ANALYSIS {
   label 'bowtie'
   publishDir "${params.outdir}/pipeline_info", mode: params.publish_dir_mode

   output:
   path ("*.txt"), emit: software_version
   script:
   """
   echo \$(bowtie --version 2>&1) > v_bowtie.txt
   """
}
process GET_TRIMGALORI_SOFTWARE_VERSION_FOR_MIRNA_ANALYSIS {
   label 'trim_galore'
   publishDir "${params.outdir}/pipeline_info", mode: params.publish_dir_mode

   output:
   path ("*.txt"), emit: software_version
   script:
   """
   trim_galore --version > v_trim_galore.txt
   """
}
process GET_FASTX_TOOLKIT_SOFTWARE_VERSION_FOR_MIRNA_ANALYSIS {
   label 'fastx_toolkit'
   publishDir "${params.outdir}/pipeline_info", mode: params.publish_dir_mode

   output:
   path ("*.txt"), emit: software_version
   script:
   """
   fasta_formatter -h > v_fastx.txt
   """
}
process GET_SAMTOOLS_SOFTWARE_VERSION_FOR_MIRNA_ANALYSIS {
   label 'samtools'
   publishDir "${params.outdir}/pipeline_info", mode: params.publish_dir_mode

   output:
   path ("*.txt"), emit: software_version
   script:
   """
   samtools --version > v_samtools.txt
   """
}
process GET_MULTIQC_SOFTWARE_VERSION_FOR_MIRNA_ANALYSIS {
   label 'multiqc'
   publishDir "${params.outdir}/pipeline_info", mode: params.publish_dir_mode

   output:
   path ("*.txt"), emit: software_version
   script:
   """
   multiqc --version > v_multiqc.txt
   """
}

process GREP_SPECIFIED_SPECIES_MATURE_MIRNA_SEQUENCE_OF_INPUT_MATURE_FASTA{
  label 'seqkit'
  publishDir "${params.outdir}/reference_prepare/mature", mode: params.publish_dir_mode
  input:
  path mature
  output:
  path ("mature_sps.fa"), emit: fasta
  script:
  """
  seqkit grep -r --pattern \".*${params.species}-.*\" $mature > mature_sps.fa
  """
}
process CONVERT_SPECIFIED_SPECIES_MATURE_MIRNA_RNA_SEQUENCE_TO_DNA_SEQUENCE {
  label 'seqkit'
  publishDir "${params.outdir}/reference_prepare/mature", mode: params.publish_dir_mode
  input:
  path mature
  output:
  path ("mature_igenome.fa"), emit: fasta
  script:
  """
  seqkit seq --rna2dna $mature > mature_igenome.fa
  """
}

process FASTA_FROMATTER_FOR_SPECIFIED_SPECIES_MATURE_MIRNA_DNA_SEQUENCE{
  label 'fastx_toolkit'
  publishDir "${params.outdir}/reference_prepare/mature", mode: params.publish_dir_mode
  input:
  path mature
  output:
  path ("mature_idx.fa"), emit: fasta
  script:
  """
  fasta_formatter -w 0 -i $mature -o mature_idx.fa
  """
}
process BOWTIE_BUILD_INDEX_FOR_FORMATTED_SPECIFIED_SPECIES_MATURE_MIRNA_DNA_SEQUENCE {
  label 'bowtie'
  input:
  path mature
  output:
  path 'bowtie' , emit:index
  script:
  """
  mkdir bowtie
  bowtie-build --threads $task.cpus $mature bowtie/${mature.baseName}
  """
}
process GREP_SPECIFIED_SPECIES_HAIRPIN_MIRNA_SEQUENCE_OF_INPUT_MATURE_FASTA{
  label 'seqkit'
  publishDir "${params.outdir}/reference_prepare/hairpin", mode: params.publish_dir_mode
  input:
  path hairpin
  output:
  path ("hairpin_sps.fa"), emit: fasta
  script:
  """
  seqkit grep -r --pattern \".*${params.species}-.*\" $hairpin > hairpin_sps.fa
  """
}
process CONVERT_SPECIFIED_SPECIES_HAIRPIN_MIRNA_RNA_SEQUENCE_TO_DNA_SEQUENCE {
  label 'seqkit'
  publishDir "${params.outdir}/reference_prepare/hairpin", mode: params.publish_dir_mode
  input:
  path hairpin
  output:
  path ("hairpin_igenome.fa"), emit: fasta
  script:
  """
  seqkit seq --rna2dna $hairpin > hairpin_igenome.fa
  """
}

process FASTA_FROMATTER_FOR_SPECIFIED_SPECIES_HAIRPIN_MIRNA_DNA_SEQUENCE{
  label 'fastx_toolkit'
  publishDir "${params.outdir}/reference_prepare/hairpin", mode: params.publish_dir_mode
  input:
  path hairpin
  output:
  path ("hairpin_idx.fa"), emit: fasta
  script:
  """
  fasta_formatter -w 0 -i $hairpin -o hairpin_idx.fa
  """
}
process BOWTIE_BUILD_INDEX_FOR_FORMATTED_SPECIFIED_SPECIES_HAIRPIN_MIRNA_DNA_SEQUENCE {
  label 'bowtie'
  input:
  path hairpin
  output:
  path 'bowtie' , emit:index
  script:
  """
  mkdir bowtie
  bowtie-build --threads $task.cpus $hairpin bowtie/${hairpin.baseName}
  """
}

process FASTQC_QUALITY_CHECK_FOR_RAW_READS {
    label 'fastqc'
    tag "$sample"
    publishDir "${params.outdir}/reads_qc/raw_reads", mode: params.publish_dir_mode
    input:
    tuple val(sample), path (reads)
    output:
    tuple val(sample), path("*.html"), emit: html
    tuple val(sample), path("*.zip") , emit: zip
    script:

    """
    fastqc --threads $task.cpus ${reads}       
    """
}
process TRIM_GALORE_RAW_READS_FILTER {
    label 'trim_galore'
    tag "$reads"
    publishDir "${params.outdir}/reads_qc/trim_galore", mode: params.publish_dir_mode

    input:
    tuple val(sample), path (reads)

    output:
    tuple val(sample),path ("*.gz"), emit:reads
    tuple val(sample),path ("*trimming_report.txt"), emit: trimgalore_results
    script:
    tg_length = "--length ${params.min_length}"
    c_r1 = clip_R1 > 0 ? "--clip_R1 ${clip_R1}" : ''
    tpc_r1 = three_prime_clip_R1 > 0 ? "--three_prime_clip_R1 ${three_prime_clip_R1}" : ''
    tpa = (protocol == "qiaseq" | protocol == "cats") ? "--adapter ${three_prime_adapter}" : '--small_rna'
    """
    trim_galore --adapter ${three_prime_adapter} $tg_length $c_r1 $tpc_r1 --max_length 100 --gzip $reads
    """
}

process FASTQC_QUALITY_CHECK_FOR_TRIMMED_READS {
    label 'fastqc'
    tag "$sample"
    publishDir "${params.outdir}/reads_qc/clean_reads", mode: params.publish_dir_mode
    input:
    tuple val(sample), path (reads)
    output:
    tuple val(sample), path("*.html"), emit: html
    tuple val(sample), path("*.zip") , emit: zip
    script:

    """
    fastqc --threads $task.cpus ${reads}       
    """
}
process BOWTIE_ALIGNMENT_FOR_FILTERED_CLEAN_READS_WITH_MATURE_MIRNA_INDEX {
    tag "sample"
    label 'bowtie'
    publishDir "${params.outdir}/bowtie_mapping/mature", mode: params.publish_dir_mode
    
    input:
    tuple val(sample), path(reads)
    path  index

    output:
    tuple val(sample), path('*.bam'), emit: bam
    tuple val(sample), path('*.out'), emit: log
    tuple val(sample), path('*fastq.gz'), optional:true, emit: fastq

    script:
    seq_center = params.seq_center ? "--sam-RG ID:${sample} --sam-RG 'CN:${params.seq_center}'" : ''
    """
    INDEX=`find -L ./ -name "*.3.ebwt" | sed 's/.3.ebwt//'`
    bowtie \\
        --threads $task.cpus \\
        --sam \\
        -x \$INDEX \\
        -q \\
        -t \\
        -k 50 \\
        --best \\
        --strata \\
        -e 99999 \\
        --chunkmbs 2048 \\
        $reads \\
        --un ${sample}.mature_unmapped.fq \\
        2> ${sample}.out \\
        | samtools view -@ $task.cpus -bS -o ${sample}.bam

    """
}
process BOWTIE_ALIGNMENT_FOR_FILTERED_CLEAN_READS_WITH_HAIRPIN_MIRNA_INDEX {
    tag "sample"
    label 'bowtie'
    publishDir "${params.outdir}/bowtie_mapping/hairpin", mode: params.publish_dir_mode
    
    input:
    tuple val(sample), path(reads)
    path  index

    output:
    tuple val(sample), path('*.bam'), emit: bam
    tuple val(sample), path('*.out'), emit: log
    tuple val(sample), path('*fastq.gz'), optional:true, emit: fastq

    script:
    seq_center = params.seq_center ? "--sam-RG ID:${sample} --sam-RG 'CN:${params.seq_center}'" : ''
    """
    INDEX=`find -L ./ -name "*.3.ebwt" | sed 's/.3.ebwt//'`
    bowtie \\
        --threads $task.cpus \\
        --sam \\
        -x \$INDEX \\
        -q \\
        -t \\
        -k 50 \\
        --best \\
        --strata \\
        -e 99999 \\
        --chunkmbs 2048 \\
        $reads \\
        --un ${sample}.mature_unmapped.fq \\
        2> ${sample}.out \\
        | samtools view -@ $task.cpus -bS -o ${sample}.bam

    """
}

process SAMTOOLS_SORTING_BAM_FOR_BOWTIE_UNSORTED_BAM_WITH_MATURE_INDEX{
    label 'samtools'
    tag "$sample"
    input:
    tuple val(sample), path (bam)
    output:
    tuple val(sample), path("*.sorted.bam") , emit:sorted_bam

    script:
    """
    samtools sort -@ $task.cpus -o ${sample}.sorted.bam -T $sample $bam
    """
}
/*
--------------------------------------------------------------------------------
Define a bam index function for pipeline
--------------------------------------------------------------------------------
*/
process SAMTOOLS_INDEX_FOR_BOWTIE_MAPPED_BAM_WITH_MATURE_INDEX {
    label 'samtools'
    tag "$sample"
    publishDir "${params.outdir}/bam_report/mature/idx_statistics",mode: 'copy'

    input:
    tuple val(sample), path (bam)

    output:
    tuple val(sample), path("*.idxstats"), emit: idxstats

    script:

    """
    samtools index $bam
    samtools idxstats $bam > ${bam}.idxstats

    """
}
/*
--------------------------------------------------------------------------------
Define a bam stat function for pipeline
--------------------------------------------------------------------------------
*/
process SAMTOOLS_STAT_FOR_BOWTIE_MAPPED_BAM_WITH_MATURE_INDEX {
    label 'samtools'
    tag "$sample"
    publishDir "${params.outdir}/bam_report/mature/statistics",mode: 'copy'

    input:
    tuple val(sample), path (bam)

    output:
    tuple val(sample), path("*.stats"), emit: stats

    script:

    """
    samtools stats $bam > ${bam}.stats

    """
}
/*
--------------------------------------------------------------------------------
Define a bam flagstat function for pipeline
--------------------------------------------------------------------------------
*/
process SAMTOOLS_FLAGSTAT_FOR_BOWTIE_MAPPED_BAM_WITH_MATURE_INDEX{
    label 'samtools'
    tag "$sample"
    publishDir "${params.outdir}/bam_report/mature/flag_statistics",mode: 'copy'

    input:
    tuple val(sample), path (bam)

    output:

    tuple val(sample), path("*.flagstat"), emit: flagstat

    script:

    """
    samtools flagstat $bam > ${bam}.flagstat

    """
}

process SAMTOOLS_SORTING_BAM_FOR_BOWTIE_UNSORTED_BAM_WITH_HAIRPIN_INDEX{
    label 'samtools'
    tag "$sample"
    input:
    tuple val(sample), path (bam)
    output:
    tuple val(sample), path("*.sorted.bam") , emit:sorted_bam

    script:
    """
    samtools sort -@ $task.cpus -o ${sample}.sorted.bam -T $sample $bam
    """

}
/*
--------------------------------------------------------------------------------
Define a bam index function for pipeline
--------------------------------------------------------------------------------
*/
process SAMTOOLS_INDEX_FOR_BOWTIE_MAPPED_BAM_WITH_HAIRPIN_INDEX {
    label 'samtools'
    tag "$sample"
    publishDir "${params.outdir}/bam_report/hairpin/idx_statistics",mode: 'copy'

    input:
    tuple val(sample), path (bam)

    output:
    tuple val(sample), path("*.idxstats"), emit: idxstats

    script:

    """
    samtools index $bam
    samtools idxstats $bam > ${bam}.idxstats

    """
}
/*
--------------------------------------------------------------------------------
Define a bam stat function for pipeline
--------------------------------------------------------------------------------
*/
process SAMTOOLS_STAT_FOR_BOWTIE_MAPPED_BAM_WITH_HAIRPIN_INDEX {
    label 'samtools'
    tag "$sample"
    publishDir "${params.outdir}/bam_report/hairpin/statistics",mode: 'copy'

    input:
    tuple val(sample), path (bam)

    output:
    tuple val(sample), path("*.stats"), emit: stats

    script:

    """
    samtools stats $bam > ${bam}.stats

    """
}
/*
--------------------------------------------------------------------------------
Define a bam flagstat function for pipeline
--------------------------------------------------------------------------------
*/
process SAMTOOLS_FLAGSTAT_FOR_BOWTIE_MAPPED_BAM_WITH_HAIRPIN_INDEX{
    label 'samtools'
    tag "$sample"
    publishDir "${params.outdir}/bam_report/hairpin/flag_statistics",mode: params.publish_dir_mode

    input:
    tuple val(sample), path (bam)

    output:

    tuple val(sample), path("*.flagstat"), emit: flagstat

    script:

    """
    samtools flagstat $bam > ${bam}.flagstat

    """
}

process EXTRACT_MIRNA_SEQUENCE_BASED_ON_GENOME_FASTA_AND_MIRBASE_GFF{

  label 'gffread'
  publishDir "${params.outdir}/reference_prepare/salmon",mode: params.publish_dir_mode
  input:
  path genome
  path gff3

  output:
  path ("salmon_input_transcripts.fa"), emit: fasta
  script:
  """
  gffread \\
    -w transcripts.fa.tmp \\
    -g ${genome} \\
    $gtf
  awk '{ if(/^>/){print \$1}else{print \$0}}' transcripts.fa.tmp > salmon_input_transcripts.fa
  """
}

process BUILD_SALMON_INDEX_FOR_MICRORNA_TRANSCRIPTS_FASTA {

  label 'salmon'
  publishDir "${params.outdir}/reference_prepare/salmon",mode: params.publish_dir_mode
  input:
  path fasta
  output:
  path "salmon", emit:index
  script:
  """
  salmon index -t $fasta -i salmon
  """
}

process SALMON_QUANT_FOR_CLEAN_READS_WITH_PREVIOUS_BUILD_INDEX{
    label 'salmon'
    tag "${sample}"
    publishDir "${params.outdir}/miRNA_quantify/salmon_quant",mode: params.publish_dir_mode

    input:
    tuple val(sample), path (reads)
    path  index
    path gtf 
    output:
    tuple val(sample),path ("${sample}") , emit:results
    script:
    def strandedness = params.single_end ? 'U' : 'IU'
    def input_reads = params.single_end ? "-r $reads" : "-1 ${reads[0]} -2 ${reads[1]}"
    """
    salmon quant \\
        --geneMap $gtf \\
        --threads $task.cpus \\
        --libType=$strandedness \\
        --index $index \\
        $input_reads\\
        -o $sample
    """
}

process BOWTIE_INDEX_BUILDING_FOR_GENOME_FASTA {
  label 'bowtie'
  publishDir "${params.outdir}/reference_prepare/bowtie_index", mode: params.publish_dir_mode
  input:
  path genome
  output:
  path 'bowtie' , emit:index
  script:
  """
  mkdir bowtie
  bowtie-build --threads $task.cpus $genome bowtie/${genome.baseName}
  """
}
process BOWTIE_ALIGNMENT_FOR_FILTERED_CLEAN_READS_WITH_GENOME_INDEX {
    tag "sample"
    label 'bowtie'
    publishDir "${params.outdir}/bowtie_mapping/genome", mode: params.publish_dir_mode
    
    input:
    tuple val(sample), path(reads)
    path  index

    output:
    tuple val(sample), path('*.bam'), emit: bam
    tuple val(sample), path('*.out'), emit: log
    tuple val(sample), path('*fastq.gz'), optional:true, emit: fastq

    script:
    seq_center = params.seq_center ? "--sam-RG ID:${sample} --sam-RG 'CN:${params.seq_center}'" : ''
    """
    INDEX=`find -L ./ -name "*.3.ebwt" | sed 's/.3.ebwt//'`
    bowtie \\
        --threads $task.cpus \\
        --sam \\
        -x \$INDEX \\
        -q \\
        -t \\
        -k 50 \\
        --best \\
        --strata \\
        -e 99999 \\
        --chunkmbs 2048 \\
        $reads \\
        --un ${sample}.mature_unmapped.fq \\
        2> ${sample}.out \\
        | samtools view -@ $task.cpus -bS -o ${sample}.bam

    """
}
process SAMTOOLS_SORTING_BAM_FOR_BOWTIE_UNSORTED_BAM_WITH_GENOME_INDEX{
    label 'samtools'
    tag "$sample"
    input:
    tuple val(sample), path (bam)
    output:
    tuple val(sample), path("*.sorted.bam") , emit:sorted_bam

    script:
    """
    samtools sort -@ $task.cpus -o ${sample}.sorted.bam -T $sample $bam
    """

}
/*
--------------------------------------------------------------------------------
Define a bam index function for pipeline
--------------------------------------------------------------------------------
*/
process SAMTOOLS_INDEX_FOR_BOWTIE_MAPPED_BAM_WITH_GENOME_INDEX {
    label 'samtools'
    tag "$sample"
    publishDir "${params.outdir}/bam_report/genome/idx_statistics",mode: params.publish_dir_mode

    input:
    tuple val(sample), path (bam)

    output:
    tuple val(sample), path("*.idxstats"), emit: idxstats

    script:

    """
    samtools index $bam
    samtools idxstats $bam > ${bam}.idxstats

    """
}
/*
--------------------------------------------------------------------------------
Define a bam stat function for pipeline
--------------------------------------------------------------------------------
*/
process SAMTOOLS_STAT_FOR_BOWTIE_MAPPED_BAM_WITH_GENOME_INDEX {
    label 'samtools'
    tag "$sample"
    publishDir "${params.outdir}/bam_report/genome/statistics",mode: params.publish_dir_mode

    input:
    tuple val(sample), path (bam)

    output:
    tuple val(sample), path("*.stats"), emit: stats

    script:

    """
    samtools stats $bam > ${bam}.stats

    """
}
/*
--------------------------------------------------------------------------------
Define a bam flagstat function for pipeline
--------------------------------------------------------------------------------
*/
process SAMTOOLS_FLAGSTAT_FOR_BOWTIE_MAPPED_BAM_WITH_GENOME_INDEX{
    label 'samtools'
    tag "$sample"
    publishDir "${params.outdir}/bam_report/genome/flag_statistics",mode: params.publish_dir_mode

    input:
    tuple val(sample), path (bam)

    output:

    tuple val(sample), path("*.flagstat"), emit: flagstat

    script:

    """
    samtools flagstat $bam > ${bam}.flagstat

    """
}

process HTSEQ_COUNTS_FOR_FOR_BOWTIE_MAPPED_BAM_WITH_GENOME_INDEX {
    label 'htseq'
    tag "$sample"
    publishDir "${params.outdir}/miRNA_quantify/htseq-count",mode: params.publish_dir_mode

    input:
    tuple val(sample), path (bam)
    path gtf

    output:

    tuple val(sample), path("*txt"), emit: results

    script:

    """
    htseq-count -f bam -s no $bam $gtf > ${sample}.txt

    """
}
process FEATURE_COUNTS_FOR_FOR_BOWTIE_MAPPED_BAM_WITH_GENOME_INDEX {
    label 'featurecounts'
    tag "$sample"
    publishDir "${params.outdir}/miRNA_quantify/featureCounts",mode: params.publish_dir_mode

    input:
    tuple val(sample), path (bam)
    path gtf

    output:

    tuple val(sample), path("*txt"), emit: results

    script:

    """
    featureCounts \\
    -T $task.cpus \\
    -F gff \\
    -M \\
    -t miRNA \\
    -g Name \\
    -a $gtf \\
    -o ${sample}.txt \\
    $bam

    """
}

process MERGE_HTSEQ_COUNTS_RESULTS {  

  input:
  path ('htseq_counts_results/*')
  output:
  path ('counts.txt'), emit: htseq_counts
  script:
  """
  ls *txt | cut -d'.' -f 1 |tr '\n' '\t' |awk '{print \$0}'| sed 's/^/'\\t'&/g' > counts.file
  paste *.txt | awk '{printf \$1"\t";for(i=2;i<=NF;i+=2) printf \$i"\t";printf \$i"\n"}' > reads_count.txt  
  cat reads_count.txt >> counts.file
  mv counts.file counts.txt
  """
}

process MULTIQC_FOR_RAW_READS_FASTQC_RESULTS {
    label 'multiqc'
    publishDir "${params.outdir}/Analysis_Report/raw_reads_fastqc", mode: params.publish_dir_mode

    input:
    path ('fastqc/*')
    
    output:
    path "*multiqc_report.html", emit: report
    path "*_data"              , emit: data
    path "*_plots"             , optional:true, emit: plots

    script:
    """
    multiqc -f --export fastqc/
    """
}

process MULTIQC_FOR_TRIM_GALORE_READS_FILTER_RESULTS {
    label 'multiqc'
    publishDir "${params.outdir}/Analysis_Report/trim_galore", mode: params.publish_dir_mode

    input:
    path ('trim_galore/*')
    
    output:
    path "*multiqc_report.html", emit: report
    path "*_data"              , emit: data
    path "*_plots"             , optional:true, emit: plots

    script:
    """
    multiqc -f --export trim_galore/
    """
}

process MULTIQC_FOR_CLEAN_READS_FASTQC_RESULTS {
    label 'multiqc'
    publishDir "${params.outdir}/Analysis_Report/clean_reads_fastqc", mode: params.publish_dir_mode

    input:
    path ('fastqc/*')
    
    output:
    path "*multiqc_report.html", emit: report
    path "*_data"              , emit: data
    path "*_plots"             , optional:true, emit: plots

    script:
    """
    multiqc -f --export fastqc/
    """
}

process MULTIQC_FOR_BOWTIE_MAPPING_RESULTS_FOR_MATURE_MAPPED_BAMS {
    label 'multiqc'
    publishDir "${params.outdir}/Analysis_Report/bowtie_mature", mode: params.publish_dir_mode

    input:
    path ('bowtie/*')
    
    output:
    path "*multiqc_report.html", emit: report
    path "*_data"              , emit: data
    path "*_plots"             , optional:true, emit: plots

    script:
    """
    multiqc -f --export bowtie/
    """
}
process MULTIQC_FOR_BOWTIE_MAPPING_RESULTS_FOR_HAIRPIN_MAPPED_BAMS {
    label 'multiqc'
    publishDir "${params.outdir}/Analysis_Report/bowtie_hairpin", mode: params.publish_dir_mode

    input:
    path ('bowtie/*')
    
    output:
    path "*multiqc_report.html", emit: report
    path "*_data"              , emit: data
    path "*_plots"             , optional:true, emit: plots

    script:
    """
    multiqc -f --export bowtie/
    """
}

process MULTIQC_SAMTOOLS_STATISTICS_RESULTS_FOR_MATURE_MAPPED_BAMS {
    label 'multiqc'
    publishDir "${params.outdir}/Analysis_Report/mature_samtools/samtools_statistics", mode: params.publish_dir_mode

    input:
    path ('samtools_stat/*')
    
    output:
    path "*multiqc_report.html", emit: report
    path "*_data"              , emit: data
    path "*_plots"             , optional:true, emit: plots

    script:
    """
    multiqc -f --export samtools_stat/
    """
}

process MULTIQC_FOR_SAMTOOLS_FLAG_STATISTICS_RESULTS_FOR_MATURE_MAPPED_BAMS {
    label 'multiqc'
    publishDir "${params.outdir}/Analysis_Report/mature_samtools/samtools_flagstat", mode: params.publish_dir_mode
    input:
    path ('samtools_flagstat/*')
    
    output:
    path "*multiqc_report.html", emit: report
    path "*_data"              , emit: data
    path "*_plots"             , optional:true, emit: plots

    script:
    """
    multiqc -f --export samtools_flagstat/
    """
}

process MULTIQC_FOR_SAMTOOLS_IDX_STATISTICS_RESULTS_FOR_MATURE_MAPPED_BAMS {
    label 'multiqc'
    publishDir "${params.outdir}/Analysis_Report/mature_samtools/samtools_idxstat", mode: params.publish_dir_mode

    input:
    path ('samtools_idxstat/*')
    
    output:
    path "*multiqc_report.html", emit: report
    path "*_data"              , emit: data
    path "*_plots"             , optional:true, emit: plots

    script:
    """
    multiqc -f --export samtools_idxstat/
    """
}

process MULTIQC_SAMTOOLS_STATISTICS_RESULTS_FOR_HAIRPIN_MAPPED_BAMS {
    label 'multiqc'
    publishDir "${params.outdir}/Analysis_Report/hairpin_samtools/samtools_statistics", mode: params.publish_dir_mode

    input:
    path ('samtools_stat/*')
    
    output:
    path "*multiqc_report.html", emit: report
    path "*_data"              , emit: data
    path "*_plots"             , optional:true, emit: plots

    script:
    """
    multiqc -f --export samtools_stat/
    """
}

process MULTIQC_FOR_SAMTOOLS_FLAG_STATISTICS_RESULTS_FOR_HAIRPIN_MAPPED_BAMS {
    label 'multiqc'
    publishDir "${params.outdir}/Analysis_Report/hairpin_samtools/samtools_flagstat", mode: params.publish_dir_mode
    input:
    path ('samtools_flagstat/*')
    
    output:
    path "*multiqc_report.html", emit: report
    path "*_data"              , emit: data
    path "*_plots"             , optional:true, emit: plots

    script:
    """
    multiqc -f --export samtools_flagstat/
    """
}

process MULTIQC_FOR_SAMTOOLS_IDX_STATISTICS_RESULTS_FOR_HAIRPIN_MAPPED_BAMS {
    label 'multiqc'
    publishDir "${params.outdir}/Analysis_Report/hairpin_samtools/samtools_idxstat", mode: params.publish_dir_mode

    input:
    path ('samtools_idxstat/*')
    
    output:
    path "*multiqc_report.html", emit: report
    path "*_data"              , emit: data
    path "*_plots"             , optional:true, emit: plots

    script:
    """
    multiqc -f --export samtools_idxstat/
    """
}
process MULTIQC_FOR_BOWTIE_MAPPING_RESULTS_FOR_GENOME_MAPPED_BAMS {
    label 'multiqc'
    publishDir "${params.outdir}/Analysis_Report/bowtie_genome", mode: params.publish_dir_mode

    input:
    path ('bowtie/*')
    
    output:
    path "*multiqc_report.html", emit: report
    path "*_data"              , emit: data
    path "*_plots"             , optional:true, emit: plots

    script:
    """
    multiqc -f --export bowtie/
    """
}

process MULTIQC_SAMTOOLS_STATISTICS_RESULTS_FOR_GENOME_MAPPED_BAMS {
    label 'multiqc'
    publishDir "${params.outdir}/Analysis_Report/genome_samtools/samtools_statistics", mode: params.publish_dir_mode

    input:
    path ('samtools_stat/*')
    
    output:
    path "*multiqc_report.html", emit: report
    path "*_data"              , emit: data
    path "*_plots"             , optional:true, emit: plots

    script:
    """
    multiqc -f --export samtools_stat/
    """
}

process MULTIQC_FOR_SAMTOOLS_FLAG_STATISTICS_RESULTS_FOR_GENOME_MAPPED_BAMS {
    label 'multiqc'
    publishDir "${params.outdir}/Analysis_Report/genome_samtools/samtools_flagstat", mode: params.publish_dir_mode
    input:
    path ('samtools_flagstat/*')
    
    output:
    path "*multiqc_report.html", emit: report
    path "*_data"              , emit: data
    path "*_plots"             , optional:true, emit: plots

    script:
    """
    multiqc -f --export samtools_flagstat/
    """
}

process MULTIQC_FOR_SAMTOOLS_IDX_STATISTICS_RESULTS_FOR_GENOME_MAPPED_BAMS {
    label 'multiqc'
    publishDir "${params.outdir}/Analysis_Report/genome_samtools/samtools_idxstat", mode: params.publish_dir_mode

    input:
    path ('samtools_idxstat/*')
    
    output:
    path "*multiqc_report.html", emit: report
    path "*_data"              , emit: data
    path "*_plots"             , optional:true, emit: plots

    script:
    """
    multiqc -f --export samtools_idxstat/
    """
}

workflow GET_SOFTWARE_VERSION_OF_PIPELINE {

  GET_NEXTFLOW_SOFTWARE_VERSION_FOR_MIRNA_ANALYSIS (  )
  GET_FASTQC_SOFTWARE_VERSION_FOR_MIRNA_ANALYSIS (  )
  GET_BOWTIE_SOFTWARE_VERSION_FOR_MIRNA_ANALYSIS (  )
  GET_TRIMGALORI_SOFTWARE_VERSION_FOR_MIRNA_ANALYSIS (  )
  GET_FASTX_TOOLKIT_SOFTWARE_VERSION_FOR_MIRNA_ANALYSIS (  )
  GET_SAMTOOLS_SOFTWARE_VERSION_FOR_MIRNA_ANALYSIS (  )
  GET_MULTIQC_SOFTWARE_VERSION_FOR_MIRNA_ANALYSIS (  )
}
workflow PREPARE_REFERENCE_FASTA_AND_INDEX_FOR_BOWTIE_MAPPING {

  take:
  mature
  hairpin
  main:
  GREP_SPECIFIED_SPECIES_MATURE_MIRNA_SEQUENCE_OF_INPUT_MATURE_FASTA ( mature )

  CONVERT_SPECIFIED_SPECIES_MATURE_MIRNA_RNA_SEQUENCE_TO_DNA_SEQUENCE ( 
  GREP_SPECIFIED_SPECIES_MATURE_MIRNA_SEQUENCE_OF_INPUT_MATURE_FASTA.out.fasta )

  FASTA_FROMATTER_FOR_SPECIFIED_SPECIES_MATURE_MIRNA_DNA_SEQUENCE (
  CONVERT_SPECIFIED_SPECIES_MATURE_MIRNA_RNA_SEQUENCE_TO_DNA_SEQUENCE.out.fasta  )

  BOWTIE_BUILD_INDEX_FOR_FORMATTED_SPECIFIED_SPECIES_MATURE_MIRNA_DNA_SEQUENCE (
  FASTA_FROMATTER_FOR_SPECIFIED_SPECIES_MATURE_MIRNA_DNA_SEQUENCE.out.fasta  )
 
  GREP_SPECIFIED_SPECIES_HAIRPIN_MIRNA_SEQUENCE_OF_INPUT_MATURE_FASTA ( hairpin )

  CONVERT_SPECIFIED_SPECIES_HAIRPIN_MIRNA_RNA_SEQUENCE_TO_DNA_SEQUENCE ( 
  GREP_SPECIFIED_SPECIES_HAIRPIN_MIRNA_SEQUENCE_OF_INPUT_MATURE_FASTA.out.fasta )

  FASTA_FROMATTER_FOR_SPECIFIED_SPECIES_HAIRPIN_MIRNA_DNA_SEQUENCE (
  CONVERT_SPECIFIED_SPECIES_HAIRPIN_MIRNA_RNA_SEQUENCE_TO_DNA_SEQUENCE.out.fasta  )

  BOWTIE_BUILD_INDEX_FOR_FORMATTED_SPECIFIED_SPECIES_HAIRPIN_MIRNA_DNA_SEQUENCE (
  FASTA_FROMATTER_FOR_SPECIFIED_SPECIES_HAIRPIN_MIRNA_DNA_SEQUENCE.out.fasta  )

  emit:
  mature_fasta   = FASTA_FROMATTER_FOR_SPECIFIED_SPECIES_MATURE_MIRNA_DNA_SEQUENCE.out.fasta 
  hairpin_fasta  = FASTA_FROMATTER_FOR_SPECIFIED_SPECIES_HAIRPIN_MIRNA_DNA_SEQUENCE.out.fasta
  mature_index   = BOWTIE_BUILD_INDEX_FOR_FORMATTED_SPECIFIED_SPECIES_MATURE_MIRNA_DNA_SEQUENCE.out.index
  hairpin_index  = BOWTIE_BUILD_INDEX_FOR_FORMATTED_SPECIFIED_SPECIES_HAIRPIN_MIRNA_DNA_SEQUENCE.out.index
}
workflow FASTQC_QUALITY_CHECK_AND_TRIM_GALORE_READS_FILTER_FOR_RAW_READS {
    take:
    reads         // channel: [ val(meta), [ reads ] ]
    main:

    raw_fastqc_html    = Channel.empty()
    raw_fastqc_zip     = Channel.empty()

    FASTQC_QUALITY_CHECK_FOR_RAW_READS ( reads ).html.set { raw_fastqc_html }
    raw_fastqc_zip     = FASTQC_QUALITY_CHECK_FOR_RAW_READS.out.zip

    //
    trim_reads = reads
    trim_log   = Channel.empty()


    TRIM_GALORE_RAW_READS_FILTER ( trim_reads ).reads.set { clean_reads }
    trim_log   = TRIM_GALORE_RAW_READS_FILTER.out.trimgalore_results


    clean_fastqc_html    = Channel.empty()
    clean_fastqc_zip     = Channel.empty()

    FASTQC_QUALITY_CHECK_FOR_TRIMMED_READS ( clean_reads ).html.set { clean_fastqc_html }
    clean_fastqc_zip     = FASTQC_QUALITY_CHECK_FOR_TRIMMED_READS.out.zip

    emit:
    reads     = clean_reads
    raw_fastqc_html     //
    clean_fastqc_html   //
    raw_fastqc_zip
    clean_fastqc_zip
    trim_log         // channel: [ val(meta), [ zip ] ]
}
workflow BOWTIE_MAPPING_FOR_CLEAN_READS_WITH_DIFFERENT_INDEX{
  take:
  mature_index
  hairpin_index
  genome_index
  reads
  main:
  BOWTIE_ALIGNMENT_FOR_FILTERED_CLEAN_READS_WITH_MATURE_MIRNA_INDEX ( reads, mature_index )
  BOWTIE_ALIGNMENT_FOR_FILTERED_CLEAN_READS_WITH_HAIRPIN_MIRNA_INDEX ( reads, hairpin_index )
  BOWTIE_ALIGNMENT_FOR_FILTERED_CLEAN_READS_WITH_GENOME_INDEX ( reads, genome_index )
  emit:
  mature_bam       = BOWTIE_ALIGNMENT_FOR_FILTERED_CLEAN_READS_WITH_MATURE_MIRNA_INDEX.out.bam
  hairpin_bam      = BOWTIE_ALIGNMENT_FOR_FILTERED_CLEAN_READS_WITH_HAIRPIN_MIRNA_INDEX.out.bam
  genome_bam       = BOWTIE_ALIGNMENT_FOR_FILTERED_CLEAN_READS_WITH_GENOME_INDEX.out.bam
  mature_bam_log   = BOWTIE_ALIGNMENT_FOR_FILTERED_CLEAN_READS_WITH_MATURE_MIRNA_INDEX.out.log
  hairpin_bam_log  = BOWTIE_ALIGNMENT_FOR_FILTERED_CLEAN_READS_WITH_HAIRPIN_MIRNA_INDEX.out.log
  genome_bam_log   = BOWTIE_ALIGNMENT_FOR_FILTERED_CLEAN_READS_WITH_GENOME_INDEX.out.log
}

workflow SAMTOOLS_SORT_STAT_FOR_BOWTIE_MAPPING_BAM_WITH_MATURE_AND_HAIRPIN_INDEX {

    take:
    mature_bam
    hairpin_bam
    genome_bam
    main:
    SAMTOOLS_SORTING_BAM_FOR_BOWTIE_UNSORTED_BAM_WITH_MATURE_INDEX ( mature_bam )

    mature_bam_for_stat      = SAMTOOLS_SORTING_BAM_FOR_BOWTIE_UNSORTED_BAM_WITH_MATURE_INDEX.out.sorted_bam
    mature_bam_for_flagstat  = SAMTOOLS_SORTING_BAM_FOR_BOWTIE_UNSORTED_BAM_WITH_MATURE_INDEX.out.sorted_bam
    mature_bam_for_idxstat   = SAMTOOLS_SORTING_BAM_FOR_BOWTIE_UNSORTED_BAM_WITH_MATURE_INDEX.out.sorted_bam

    SAMTOOLS_INDEX_FOR_BOWTIE_MAPPED_BAM_WITH_MATURE_INDEX ( mature_bam_for_idxstat )
    SAMTOOLS_STAT_FOR_BOWTIE_MAPPED_BAM_WITH_MATURE_INDEX ( mature_bam_for_stat )
    SAMTOOLS_FLAGSTAT_FOR_BOWTIE_MAPPED_BAM_WITH_MATURE_INDEX ( mature_bam_for_flagstat )
    ////
    SAMTOOLS_SORTING_BAM_FOR_BOWTIE_UNSORTED_BAM_WITH_HAIRPIN_INDEX ( hairpin_bam )
    hairpin_bam_for_stat      = SAMTOOLS_SORTING_BAM_FOR_BOWTIE_UNSORTED_BAM_WITH_HAIRPIN_INDEX.out.sorted_bam
    hairpin_bam_for_flagstat  = SAMTOOLS_SORTING_BAM_FOR_BOWTIE_UNSORTED_BAM_WITH_HAIRPIN_INDEX.out.sorted_bam
    hairpin_bam_for_idxstat   = SAMTOOLS_SORTING_BAM_FOR_BOWTIE_UNSORTED_BAM_WITH_HAIRPIN_INDEX.out.sorted_bam
    SAMTOOLS_INDEX_FOR_BOWTIE_MAPPED_BAM_WITH_HAIRPIN_INDEX ( hairpin_bam_for_idxstat )
    SAMTOOLS_STAT_FOR_BOWTIE_MAPPED_BAM_WITH_HAIRPIN_INDEX ( hairpin_bam_for_stat )
    SAMTOOLS_FLAGSTAT_FOR_BOWTIE_MAPPED_BAM_WITH_HAIRPIN_INDEX ( hairpin_bam_for_flagstat )

    SAMTOOLS_SORTING_BAM_FOR_BOWTIE_UNSORTED_BAM_WITH_GENOME_INDEX ( genome_bam )

    genome_bam_for_stat       = SAMTOOLS_SORTING_BAM_FOR_BOWTIE_UNSORTED_BAM_WITH_GENOME_INDEX.out.sorted_bam
    genome_bam_for_flagstat   = SAMTOOLS_SORTING_BAM_FOR_BOWTIE_UNSORTED_BAM_WITH_GENOME_INDEX.out.sorted_bam
    genome_bam_for_idxstat    = SAMTOOLS_SORTING_BAM_FOR_BOWTIE_UNSORTED_BAM_WITH_GENOME_INDEX.out.sorted_bam

    SAMTOOLS_INDEX_FOR_BOWTIE_MAPPED_BAM_WITH_GENOME_INDEX ( genome_bam_for_idxstat )
    SAMTOOLS_STAT_FOR_BOWTIE_MAPPED_BAM_WITH_GENOME_INDEX ( genome_bam_for_stat )
    SAMTOOLS_FLAGSTAT_FOR_BOWTIE_MAPPED_BAM_WITH_GENOME_INDEX ( genome_bam_for_flagstat )

    emit:
    mature_sorted_bam        = SAMTOOLS_SORTING_BAM_FOR_BOWTIE_UNSORTED_BAM_WITH_MATURE_INDEX.out.sorted_bam
    hairpin_sorted_bam       = SAMTOOLS_SORTING_BAM_FOR_BOWTIE_UNSORTED_BAM_WITH_HAIRPIN_INDEX.out.sorted_bam
    genome_sorted_bam        = SAMTOOLS_SORTING_BAM_FOR_BOWTIE_UNSORTED_BAM_WITH_GENOME_INDEX.out.sorted_bam

    mature_bam_stat       = SAMTOOLS_STAT_FOR_BOWTIE_MAPPED_BAM_WITH_MATURE_INDEX.out.stats
    mature_bam_flagstat   = SAMTOOLS_FLAGSTAT_FOR_BOWTIE_MAPPED_BAM_WITH_MATURE_INDEX.out.flagstat
    mature_bam_idxstat    = SAMTOOLS_INDEX_FOR_BOWTIE_MAPPED_BAM_WITH_MATURE_INDEX.out.idxstats
    hairpin_bam_stat      = SAMTOOLS_STAT_FOR_BOWTIE_MAPPED_BAM_WITH_HAIRPIN_INDEX.out.stats
    hairpin_bam_flagstat  = SAMTOOLS_FLAGSTAT_FOR_BOWTIE_MAPPED_BAM_WITH_HAIRPIN_INDEX.out.flagstat
    hairpin_bam_idxstat   = SAMTOOLS_INDEX_FOR_BOWTIE_MAPPED_BAM_WITH_HAIRPIN_INDEX.out.idxstats
    genome_bam_stat       = SAMTOOLS_STAT_FOR_BOWTIE_MAPPED_BAM_WITH_GENOME_INDEX.out.stats
    genome_bam_flagstat   = SAMTOOLS_FLAGSTAT_FOR_BOWTIE_MAPPED_BAM_WITH_GENOME_INDEX.out.flagstat
    genome_bam_idxstat    = SAMTOOLS_INDEX_FOR_BOWTIE_MAPPED_BAM_WITH_GENOME_INDEX.out.idxstats

}

workflow MULTIQC_FOR_ALL_STEPS_OF_MIRNA_ANALYSIS {

    take:
    raw_reads_fastqc_zip
    trim_galore_results 
    clean_reads_fastqc_zip
    bowtie_mature_out
    bowtie_hairpin_out
    mature_samtools_stat_results
    mature_samtools_flagstat_results
    mature_samtools_idxstat_results
    hairpin_samtools_stat_results
    hairpin_samtools_flagstat_results
    hairpin_samtools_idxstat_results
    bowtie_genome_out
    genome_samtools_stat_results
    genome_samtools_flagstat_results
    genome_samtools_idxstat_results

    main:
    MULTIQC_FOR_RAW_READS_FASTQC_RESULTS ( raw_reads_fastqc_zip )
    MULTIQC_FOR_TRIM_GALORE_READS_FILTER_RESULTS ( trim_galore_results )
    MULTIQC_FOR_CLEAN_READS_FASTQC_RESULTS ( clean_reads_fastqc_zip )
    MULTIQC_FOR_BOWTIE_MAPPING_RESULTS_FOR_MATURE_MAPPED_BAMS ( bowtie_mature_out )
    MULTIQC_FOR_BOWTIE_MAPPING_RESULTS_FOR_HAIRPIN_MAPPED_BAMS ( bowtie_hairpin_out )
    MULTIQC_SAMTOOLS_STATISTICS_RESULTS_FOR_MATURE_MAPPED_BAMS ( mature_samtools_stat_results )
    MULTIQC_FOR_SAMTOOLS_FLAG_STATISTICS_RESULTS_FOR_MATURE_MAPPED_BAMS ( mature_samtools_flagstat_results )
    MULTIQC_FOR_SAMTOOLS_IDX_STATISTICS_RESULTS_FOR_MATURE_MAPPED_BAMS ( mature_samtools_idxstat_results )
    MULTIQC_SAMTOOLS_STATISTICS_RESULTS_FOR_HAIRPIN_MAPPED_BAMS ( hairpin_samtools_stat_results )
    MULTIQC_FOR_SAMTOOLS_FLAG_STATISTICS_RESULTS_FOR_HAIRPIN_MAPPED_BAMS ( hairpin_samtools_flagstat_results )
    MULTIQC_FOR_SAMTOOLS_IDX_STATISTICS_RESULTS_FOR_HAIRPIN_MAPPED_BAMS ( hairpin_samtools_idxstat_results )
    MULTIQC_FOR_BOWTIE_MAPPING_RESULTS_FOR_GENOME_MAPPED_BAMS ( bowtie_genome_out )
    MULTIQC_SAMTOOLS_STATISTICS_RESULTS_FOR_GENOME_MAPPED_BAMS ( genome_samtools_stat_results )
    MULTIQC_FOR_SAMTOOLS_FLAG_STATISTICS_RESULTS_FOR_GENOME_MAPPED_BAMS ( genome_samtools_flagstat_results )
    MULTIQC_FOR_SAMTOOLS_IDX_STATISTICS_RESULTS_FOR_GENOME_MAPPED_BAMS ( genome_samtools_idxstat_results )
}

workflow SALMON_INDEX_BUILDING_AND_QUANT_FOR_TRIMMED_READS_OF_SMALL_RNASEQ{

  take:
  genome
  gtf
  reads

  main:
  EXTRACT_MIRNA_SEQUENCE_BASED_ON_GENOME_FASTA_AND_MIRBASE_GFF ( genome, gtf )
  BUILD_SALMON_INDEX_FOR_MICRORNA_TRANSCRIPTS_FASTA ( EXTRACT_MIRNA_SEQUENCE_BASED_ON_GENOME_FASTA_AND_MIRBASE_GFF.out.fasta )
  SALMON_QUANT_FOR_CLEAN_READS_WITH_PREVIOUS_BUILD_INDEX ( reads, BUILD_SALMON_INDEX_FOR_MICRORNA_TRANSCRIPTS_FASTA.out.index, gtf )
  emit:
  index     = BUILD_SALMON_INDEX_FOR_MICRORNA_TRANSCRIPTS_FASTA.out.index
  miRNA_transcripts_fasta = EXTRACT_MIRNA_SEQUENCE_BASED_ON_GENOME_FASTA_AND_MIRBASE_GFF.out.fasta
  salmon_quant_results    = SALMON_QUANT_FOR_CLEAN_READS_WITH_PREVIOUS_BUILD_INDEX.out.results
}


/*
=======================================================================================================
THIS IS THE START OF MIRNA PIPELINE
=======================================================================================================
*/

workflow {

  GET_SOFTWARE_VERSION_OF_PIPELINE (  )

  if (params.mature)  { mature  = file(params.mature, checkIfExists: true) } 
  else { exit 1, "Mature file not found: ${params.mature}" }
  if (params.hairpin) { hairpin = file(params.hairpin, checkIfExists: true) } 
  else { exit 1, "Hairpin file not found: ${params.hairpin}" }
  if (params.genome) { genome = file(params.genome, checkIfExists: true) }


  PREPARE_REFERENCE_FASTA_AND_INDEX_FOR_BOWTIE_MAPPING ( mature, hairpin )

  FASTQC_QUALITY_CHECK_AND_TRIM_GALORE_READS_FILTER_FOR_RAW_READS ( raw_reads )

  if ( params.genome_mapping ){
  if ( !params.bowtie_index ){
      BOWTIE_INDEX_BUILDING_FOR_GENOME_FASTA ( genome )
    }

  }

  BOWTIE_MAPPING_FOR_CLEAN_READS_WITH_DIFFERENT_INDEX ( PREPARE_REFERENCE_FASTA_AND_INDEX_FOR_BOWTIE_MAPPING.out.mature_index,
  PREPARE_REFERENCE_FASTA_AND_INDEX_FOR_BOWTIE_MAPPING.out.hairpin_index,
  BOWTIE_INDEX_BUILDING_FOR_GENOME_FASTA.out.index,
  FASTQC_QUALITY_CHECK_AND_TRIM_GALORE_READS_FILTER_FOR_RAW_READS.out.reads )

  genome_bam_for_htseq = BOWTIE_MAPPING_FOR_CLEAN_READS_WITH_DIFFERENT_INDEX.out.genome_bam
  genome_bam_for_featurecounts = BOWTIE_MAPPING_FOR_CLEAN_READS_WITH_DIFFERENT_INDEX.out.genome_bam
  HTSEQ_COUNTS_FOR_FOR_BOWTIE_MAPPED_BAM_WITH_GENOME_INDEX ( genome_bam_for_htseq, gtf )
  FEATURE_COUNTS_FOR_FOR_BOWTIE_MAPPED_BAM_WITH_GENOME_INDEX ( genome_bam_for_featurecounts, gtf )
  //MERGE_HTSEQ_COUNTS_RESULTS ( HTSEQ_COUNTS_FOR_FOR_BOWTIE_MAPPED_BAM_WITH_GENOME_INDEX.out.results.collect{it[1]})

  SAMTOOLS_SORT_STAT_FOR_BOWTIE_MAPPING_BAM_WITH_MATURE_AND_HAIRPIN_INDEX ( 
  BOWTIE_MAPPING_FOR_CLEAN_READS_WITH_DIFFERENT_INDEX.out.mature_bam,
  BOWTIE_MAPPING_FOR_CLEAN_READS_WITH_DIFFERENT_INDEX.out.hairpin_bam,
  BOWTIE_MAPPING_FOR_CLEAN_READS_WITH_DIFFERENT_INDEX.out.genome_bam
  )

  MULTIQC_FOR_ALL_STEPS_OF_MIRNA_ANALYSIS ( 
    FASTQC_QUALITY_CHECK_AND_TRIM_GALORE_READS_FILTER_FOR_RAW_READS.out.raw_fastqc_zip.collect{it[1]}, 
    FASTQC_QUALITY_CHECK_AND_TRIM_GALORE_READS_FILTER_FOR_RAW_READS.out.trim_log.collect{it[1]}, 
    FASTQC_QUALITY_CHECK_AND_TRIM_GALORE_READS_FILTER_FOR_RAW_READS.out.clean_fastqc_zip.collect{it[1]},
    BOWTIE_MAPPING_FOR_CLEAN_READS_WITH_DIFFERENT_INDEX.out.mature_bam_log.collect{it[1]},
    BOWTIE_MAPPING_FOR_CLEAN_READS_WITH_DIFFERENT_INDEX.out.hairpin_bam_log.collect{it[1]},
    SAMTOOLS_SORT_STAT_FOR_BOWTIE_MAPPING_BAM_WITH_MATURE_AND_HAIRPIN_INDEX.out.mature_bam_stat.collect{it[1]},
    SAMTOOLS_SORT_STAT_FOR_BOWTIE_MAPPING_BAM_WITH_MATURE_AND_HAIRPIN_INDEX.out.mature_bam_flagstat.collect{it[1]},
    SAMTOOLS_SORT_STAT_FOR_BOWTIE_MAPPING_BAM_WITH_MATURE_AND_HAIRPIN_INDEX.out.mature_bam_idxstat.collect{it[1]},
    SAMTOOLS_SORT_STAT_FOR_BOWTIE_MAPPING_BAM_WITH_MATURE_AND_HAIRPIN_INDEX.out.hairpin_bam_stat.collect{it[1]},
    SAMTOOLS_SORT_STAT_FOR_BOWTIE_MAPPING_BAM_WITH_MATURE_AND_HAIRPIN_INDEX.out.hairpin_bam_flagstat.collect{it[1]},
    SAMTOOLS_SORT_STAT_FOR_BOWTIE_MAPPING_BAM_WITH_MATURE_AND_HAIRPIN_INDEX.out.hairpin_bam_idxstat.collect{it[1]},
    BOWTIE_MAPPING_FOR_CLEAN_READS_WITH_DIFFERENT_INDEX.out.genome_bam_log.collect{it[1]},
    SAMTOOLS_SORT_STAT_FOR_BOWTIE_MAPPING_BAM_WITH_MATURE_AND_HAIRPIN_INDEX.out.genome_bam_stat.collect{it[1]},
    SAMTOOLS_SORT_STAT_FOR_BOWTIE_MAPPING_BAM_WITH_MATURE_AND_HAIRPIN_INDEX.out.genome_bam_flagstat.collect{it[1]},
    SAMTOOLS_SORT_STAT_FOR_BOWTIE_MAPPING_BAM_WITH_MATURE_AND_HAIRPIN_INDEX.out.genome_bam_idxstat.collect{it[1]}

) 

  if ( params.salmon ){
    clean_reads_for_salmon_quant = FASTQC_QUALITY_CHECK_AND_TRIM_GALORE_READS_FILTER_FOR_RAW_READS.out.reads
    SALMON_INDEX_BUILDING_AND_QUANT_FOR_TRIMMED_READS_OF_SMALL_RNASEQ ( genome, gtf, clean_reads_for_salmon_quant )
  }

    
}

